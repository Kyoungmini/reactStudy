<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>js class</title>
</head>

<body>
    <h1>class</h1>
    <h2>class 선언법</h2>
    <ul>
        <li>class Name{} (호이스팅이 일어나지 않는다)</li>
        <li>== const Name=function(){}(호이스팅이 일어나지 않는 객체 선언법) </li>
      
        <li>class Name{ peoperty=""; }</li>
        <li>== conat Name=function(){this.property=""; }</li>
   
        <li>class Name{  functionName(){}}</li>
        <li>== conat Name=function(){  this.functionName(){} }</li>
    </ul>
    <h2>객체와 prototype</h2>
    <ul>
        <li>class와 function을 선언하면 prototype이 생성된다.</li>
        <li>new 연산자로 객체를 생성하면 prototype을 기반으로 객체가 만들어진다.</li>
        <li>이때 해당 function에서 this 선언한 property와 class의 바디에 선언한 property가 객체의 필드가된다.(this로 접근가능한 것)</li>
        <li>모든 prototype은 __proto__로 연결(상속)가능하고 최상위 객체 즉 최상위 __proto__는 Object 다.(Object가 모든 prototype의 부모다)</li>
        <li>자바스크립트를 프로토타입 언어라 부른다.</li>
        <li>생성된 객체의 __proto__(부모)는 객체의 prototype이다 (객체는 prototype을 기반으로 생성된다.)</li>
        <li>prototype에 constructor(생성자)가 존재한다.</li>
        <li>class를 선언하는 행위를 추상화라 부른다.(설계도를 만든다)</li>
        <li>만약 객체를 생성하지 않고 필드를 선언하고 싶다면 prototype에 필드를 명시하면 된다. (static 필드)
            <ul>
                <li>
                    예) Number.PI : <script>
                        console.log(new Number().MAX_VALUE);
                        document.write(Number.MAX_VALUE)</script>
                </li>
                <li>
                    new StaticTest().noneStatic : 
                    <script>
                        class StaticTest{
                            noneStatic="인스턴스 객체의 필드";
                            static STATIC_FIELD="스태틱 필드";
                        }
                        document.write(new StaticTest().noneStatic)
                    </script>
                </li>
                <li>StaticTest.noneStatic :
                    <script>
                        document.write(StaticTest.noneStatic)
                    </script>
                </li>
                <li>StaticTest.STATIC_FIELD :
                    <script>
                        document.write(StaticTest.STATIC_FIELD)
                        console.log("StaticTest.prototype",StaticTest.prototype);
                    </script>
                </li>
                <li>
                    class의 prototype은 class 선언시 객체로 만들어지기 때문이다.
                </li>
            </ul>
        </li>
    </ul>
<script>
//함수    
function move(){
    let id="3450";
    const logo="르노삼성";
}
//객체의 프로토타입을 정의    
function Car(id){
    //id=id;  //==var id=id; //window.id
    this.id=id; //new Car().id
    this.logo="르노삼성";
    this.move=function(){
        console.log(this.id+" "+this.logo+"인 차가 움직인다.");
    }
}
//new 연산자 : 객체를 생성하는 연산자로 프로토타입의 생성자를 호출해야 한다.
//new Car() this로 선언한 id,logo가 객체의 프로퍼티가된다.
//프로퍼티를 정의하는 것 프로토타입 == 설계도

console.log(new move());
console.log(new Car("3450"));
console.log(new Car("8724"));
console.log(new Car("8724").move());

class Car2{
    //var name;
    //let name;
    //const name;
    //this.id="3450";
    //logo: "르노삼성";
    id="3450";
    //logo="르노삼성"; //생략가능(생성자에서 this로 선언 가능)
    constructor(para_id,logo){
        //id=para_id;
        this.id=para_id;
        this.logo=logo;
    }
    //function name(params) {}
    move(dir){
        console.log(this.id+" "+this.logo+"인 차가 "+dir+" 움직인다.");
    }
}
console.log(new Car2("1234","BMW"));
console.log(new Car2("1234","BMW").move("오른쪽"));


console.log(new Car2("5678","르노삼성"));
console.log("new Car2().id",new Car2("8888","fox").id)
console.log("Car2.id",Car2.id);

const car3={id:"7777",logo:"fox"};
console.log(car3);

console.log("//////////////////////////////////////");
console.log(Car.prototype);
console.log(Car2.prototype);

console.log(Car2.prototype.__proto__);
console.log(Car.prototype.__proto__);
console.log(Car.prototype.__proto__.__proto__);

console.log(new Car2().prototype);
console.log(new Car2().__proto__);

</script>


</body>
</html>